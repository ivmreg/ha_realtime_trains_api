blueprint:
  name: Track Train by Service UID (AM & PM) – REST Command
  description: >
    Queries RTT timetable+realtime overlays for two services (AM and PM) using rest_command,
    checks platform, delay, cancellation, and sends a notification. Only runs on selected weekdays.
  domain: automation

  input:
    rtt_username:
      name: RTT API Username
      selector:
        text: {}

    rtt_password:
      name: RTT API Password
      selector:
        text:
          type: password

    days:
      name: Days of Week
      description: "Automation only runs on these days"
      selector:
        select:
          multiple: true
          mode: list
          options:
            - Monday
            - Tuesday
            - Wednesday
            - Thursday
            - Friday
            - Saturday
            - Sunday

    morning_uid:
      name: Morning Train Service UID
      selector:
        text: {}

    morning_trigger_time:
      name: Morning Check Time
      selector:
        time: {}

    evening_uid:
      name: Evening Train Service UID
      selector:
        text: {}

    evening_trigger_time:
      name: Evening Check Time
      selector:
        time: {}

    notify_device:
      name: Send Notifications To
      selector:
        device:
          filter:
            - integration: mobile_app

trigger:
  - platform: time
    at: !input morning_trigger_time
    id: morning

  - platform: time
    at: !input evening_trigger_time
    id: evening

condition:
  - condition: template
    value_template: >
      {{ now().strftime('%A') in !input days }}

variables:
  service_uid: >
    {% if trigger.id == "morning" %}
      {{ !input morning_uid }}
    {% else %}
      {{ !input evening_uid }}
    {% endif %}

  today: "{{ now().strftime('%Y/%m/%d') }}"

action:
  - service: rest_command.rtt_service
    data:
      uid: "{{ service_uid }}"
      date: "{{ today }}"
    response_variable: rtt_response

  - variables:
      rtt_json: "{{ rtt_response.content | from_json }}"
      first_stop: "{{ rtt_json.locations[0] }}"
      is_cancelled: "{{ first_stop.isCancelled | default(false) }}"
      cancel_reason: "{{ first_stop.cancelReason | default('Unknown') }}"
      platform: "{{ first_stop.realtimePlatform or first_stop.platform | default('—') }}"
      gbtt_departure: "{{ first_stop.gbttDeparture | default('—') }}"
      realtime_departure: "{{ first_stop.realtimeDeparture | default('—') }}"
      delay_min: >
        {% if first_stop.gbttDeparture and first_stop.realtimeDeparture %}
          {{ (strptime(first_stop.realtimeDeparture, '%H:%M') -
              strptime(first_stop.gbttDeparture, '%H:%M')).total_seconds() / 60 | round(0) }}
        {% else %}
          0
        {% endif %}

  - choose:
      - conditions: "{{ is_cancelled }}"
        sequence:
          - device_id: !input notify_device
            domain: mobile_app
            type: notify
            message: >
              ❌ Train {{ service_uid }} is CANCELLED
              Scheduled: {{ gbtt_departure }}
              Reason: {{ cancel_reason }}

      - conditions: "{{ delay_min | int > 0 }}"
        sequence:
          - device_id: !input notify_device
            domain: mobile_app
            type: notify
            message: >
              ⚠️ Train {{ service_uid }} is DELAYED
              Scheduled: {{ gbtt_departure }}
              Expected: {{ realtime_departure }}
              Delay: {{ delay_min }} min
              Platform: {{ platform }}

    default:
      - device_id: !input notify_device
        domain: mobile_app
        type: notify
        message: >
          ✅ Train {{ service_uid }} ON TIME
          Departure: {{ gbtt_departure }}
          Platform: {{ platform }}

mode: single
